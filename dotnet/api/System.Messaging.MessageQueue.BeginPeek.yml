### YamlMime:NetMember
type: method
threadSafety:
  customizedContent: The method is not thread safe.
members:
- returns:
    description: The <xref data-throw-if-not-resolved="true" uid="System.IAsyncResult"></xref> that identifies the posted asynchronous request.
    type: <xref href="System.IAsyncResult?alt=System.IAsyncResult&text=IAsyncResult" data-throw-if-not-resolved="True"/>
  parameters:
  - namesWithMoniker:
    - value: timeout
    description: A <xref data-throw-if-not-resolved="true" uid="System.TimeSpan"></xref> that indicates the interval of time to wait for a message to become available.
    type: <xref href="System.TimeSpan?alt=System.TimeSpan&text=TimeSpan" data-throw-if-not-resolved="True"/>
  - namesWithMoniker:
    - value: stateObject
    description: A state object, specified by the application, that contains information associated with the asynchronous operation.
    type: <xref href="System.Object?alt=System.Object&text=Object" data-throw-if-not-resolved="True"/>
  - namesWithMoniker:
    - value: callback
    description: The <xref data-throw-if-not-resolved="true" uid="System.AsyncCallback"></xref> that will receive the notification of the asynchronous operation completion.
    type: <xref href="System.AsyncCallback?alt=System.AsyncCallback&text=AsyncCallback" data-throw-if-not-resolved="True"/>
  exceptions:
  - description: The value specified for the <code data-dev-comment-type="paramref">timeout</code> parameter is not valid.
    type: <xref href="System.ArgumentException?alt=System.ArgumentException&text=ArgumentException" data-throw-if-not-resolved="True"/>
  - description: An error occurred when accessing a Message Queuing method.
    type: <xref href="System.Messaging.MessageQueueException?alt=System.Messaging.MessageQueueException&text=MessageQueueException" data-throw-if-not-resolved="True"/>
  uid: System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)
  commentId: M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)
  name: BeginPeek(TimeSpan, Object, AsyncCallback)
  fullName: System.Messaging.MessageQueue.BeginPeek(TimeSpan, Object, AsyncCallback)
  nameWithType: MessageQueue.BeginPeek(TimeSpan, Object, AsyncCallback)
  syntaxWithMoniker:
  - lang: cpp
    values:
    - value: >-
        public:
         IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);
  - lang: csharp
    values:
    - value: public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);
  - lang: fsharp
    values:
    - value: 'member this.BeginPeek : TimeSpan * obj * AsyncCallback -> IAsyncResult'
  - lang: vb
    values:
    - value: Public Function BeginPeek (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult
  monikers:
  - netframework-1.1
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
  - netframework-4.5
  - netframework-4.5.1
  - netframework-4.5.2
  - netframework-4.6
  - netframework-4.6.1
  - netframework-4.6.2
  - netframework-4.7
  - netframework-4.7.1
  - netframework-4.7.2
  - netframework-4.8
  - xamarinmac-3.0
  seeAlso: >+
    - <xref:System.Messaging.MessageQueue.PeekCompleted>

    - <xref:System.Messaging.MessageQueue.BeginReceive>

    - <xref:System.Messaging.MessageQueue.Peek>

    - <xref:System.Messaging.MessageQueue.Receive>

    - <xref:System.AsyncCallback>

    - <xref:System.TimeSpan>

  summary: Initiates an asynchronous peek operation that has a specified time-out and a specified state object, which provides associated information throughout the operation's lifetime. This overload receives notification, through a callback, of the identity of the event handler for the operation. The operation is not complete until either a message becomes available in the queue or the time-out occurs.
  remarks: "When you use this overload, the callback specified in the callback parameter is invoked directly when a message becomes available in the queue or when the specified interval of time has expired; the <xref:System.Messaging.MessageQueue.PeekCompleted> event is not raised. The other overloads of <xref:System.Messaging.MessageQueue.BeginPeek%2A> rely on this component to raise the <xref:System.Messaging.MessageQueue.PeekCompleted> event.  \n  \n <xref:System.Messaging.MessageQueue.PeekCompleted> is also raised if a message already exists in the queue.  \n  \n The <xref:System.Messaging.MessageQueue.BeginPeek%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.  \n  \n Because <xref:System.Messaging.MessageQueue.BeginPeek%2A> is asynchronous, you can call it to peek the queue without blocking the current thread of execution. To synchronously peek the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.  \n  \n Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.  \n  \n <xref:System.Messaging.MessageQueue.BeginPeek%2A> returns a <xref:System.IAsyncResult> that identifies the asynchronous operation that the method started. You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> is called. However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete. In this case, you use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.  \n  \n The state object associates state information with the operation. For example, if you call <xref:System.Messaging.MessageQueue.BeginPeek%2A> multiple times to initiate multiple operations, you can identify each operation through a separate state object that you define.  \n  \n The following table shows whether this method is available in various Workgroup modes.  \n  \n|Workgroup mode|Available|  \n|--------------------|---------------|  \n|Local computer|Yes|  \n|Local computer and direct format name|Yes|  \n|Remote computer|No|  \n|Remote computer and direct format name|Yes|"
  examples: "The following code example creates an asynchronous peek operation. The code example sends a message to a local message queue, then calls <xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, passing in: a time-out value of ten seconds; a unique integer that identifies that particular message; and a new instance of <xref:System.AsyncCallback> that identifies the event handler, `MyPeekCompleted`. When a <xref:System.Messaging.MessageQueue.PeekCompleted> event is raised, the event handler peeks at the message and writes the message body and the integer message identifier to the screen.  \n  \n [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]\n [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]"
  metadata: {}
- returns:
    description: The <xref data-throw-if-not-resolved="true" uid="System.IAsyncResult"></xref> that identifies the posted asynchronous request.
    type: <xref href="System.IAsyncResult?alt=System.IAsyncResult&text=IAsyncResult" data-throw-if-not-resolved="True"/>
  parameters:
  - namesWithMoniker:
    - value: timeout
    description: A <xref data-throw-if-not-resolved="true" uid="System.TimeSpan"></xref> that indicates the interval of time to wait for a message to become available.
    type: <xref href="System.TimeSpan?alt=System.TimeSpan&text=TimeSpan" data-throw-if-not-resolved="True"/>
  - namesWithMoniker:
    - value: stateObject
    description: A state object, specified by the application, that contains information associated with the asynchronous operation.
    type: <xref href="System.Object?alt=System.Object&text=Object" data-throw-if-not-resolved="True"/>
  exceptions:
  - description: The value specified for the <code data-dev-comment-type="paramref">timeout</code> parameter is not valid.
    type: <xref href="System.ArgumentException?alt=System.ArgumentException&text=ArgumentException" data-throw-if-not-resolved="True"/>
  - description: An error occurred when accessing a Message Queuing method.
    type: <xref href="System.Messaging.MessageQueueException?alt=System.Messaging.MessageQueueException&text=MessageQueueException" data-throw-if-not-resolved="True"/>
  uid: System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)
  commentId: M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)
  name: BeginPeek(TimeSpan, Object)
  fullName: System.Messaging.MessageQueue.BeginPeek(TimeSpan, Object)
  nameWithType: MessageQueue.BeginPeek(TimeSpan, Object)
  syntaxWithMoniker:
  - lang: cpp
    values:
    - value: >-
        public:
         IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject);
  - lang: csharp
    values:
    - value: public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);
  - lang: fsharp
    values:
    - value: 'member this.BeginPeek : TimeSpan * obj -> IAsyncResult'
  - lang: vb
    values:
    - value: Public Function BeginPeek (timeout As TimeSpan, stateObject As Object) As IAsyncResult
  monikers:
  - netframework-1.1
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
  - netframework-4.5
  - netframework-4.5.1
  - netframework-4.5.2
  - netframework-4.6
  - netframework-4.6.1
  - netframework-4.6.2
  - netframework-4.7
  - netframework-4.7.1
  - netframework-4.7.2
  - netframework-4.8
  - xamarinmac-3.0
  seeAlso: >+
    - <xref:System.Messaging.MessageQueue.PeekCompleted>

    - <xref:System.Messaging.MessageQueue.BeginReceive>

    - <xref:System.Messaging.MessageQueue.Peek>

    - <xref:System.Messaging.MessageQueue.Receive>

    - <xref:System.TimeSpan>

  summary: Initiates an asynchronous peek operation that has a specified time-out and a specified state object, which provides associated information throughout the operation's lifetime. The operation is not complete until either a message becomes available in the queue or the time-out occurs.
  remarks: "In asynchronous processing, you use <xref:System.Messaging.MessageQueue.BeginPeek%2A> to raise the <xref:System.Messaging.MessageQueue.PeekCompleted> event when a message becomes available in the queue or when the specified interval of time has expired.  \n  \n <xref:System.Messaging.MessageQueue.PeekCompleted> is also raised if a message already exists in the queue.  \n  \n Use this overload to associate information with the operation that will be preserved throughout the operation's lifetime. The event handler can access this information by looking at the <xref:System.IAsyncResult.AsyncState%2A> property of the <xref:System.IAsyncResult> that is associated with the operation.  \n  \n To use <xref:System.Messaging.MessageQueue.BeginPeek%2A>, create an event handler that processes the results of the asynchronous operation, and associate it with your event delegate. <xref:System.Messaging.MessageQueue.BeginPeek%2A> initiates an asynchronous peek operation; the <xref:System.Messaging.MessageQueue> is notified, through the raising of the <xref:System.Messaging.MessageQueue.PeekCompleted> event, when a message arrives in the queue. The <xref:System.Messaging.MessageQueue> can then access the message by calling <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> or by retrieving the result using the <xref:System.Messaging.PeekCompletedEventArgs>.  \n  \n The <xref:System.Messaging.MessageQueue.BeginPeek%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.  \n  \n Because <xref:System.Messaging.MessageQueue.BeginPeek%2A> is asynchronous, you can call it to peek the queue without blocking the current thread of execution. To synchronously peek the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.  \n  \n Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.  \n  \n <xref:System.Messaging.MessageQueue.BeginPeek%2A> returns a <xref:System.IAsyncResult> that identifies the asynchronous operation that the method started. You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> is called. However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete. In this case, you use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.  \n  \n This overload specifies a time-out and a state object. If the interval specified by the `timeout` parameter expires, this component raises the <xref:System.Messaging.MessageQueue.PeekCompleted> event. Because no message exists, a subsequent call to <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> will throw an exception.  \n  \n The state object associates state information with the operation. For example, if you call <xref:System.Messaging.MessageQueue.BeginPeek%2A> multiple times to initiate multiple operations, you can identify each operation through a separate state object that you define. For an illustration of this scenario, see the Example section.  \n  \n You can also use the state object to pass information across process threads. If a thread is started but the callback is on a different thread in an asynchronous scenario, the state object is marshaled and passed back along with information from the event.  \n  \n If <xref:System.Messaging.MessageQueue.CanRead%2A> is `false`, the completion event is raised, but an exception will be thrown when calling <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  \n  \n The following table shows whether this method is available in various Workgroup modes.  \n  \n|Workgroup mode|Available|  \n|--------------------|---------------|  \n|Local computer|Yes|  \n|Local computer and direct format name|Yes|  \n|Remote computer|No|  \n|Remote computer and direct format name|Yes|"
  examples: "The following code example creates an asynchronous peek operation, using the queue path \".\\myQueue\". It creates an event handler, `MyPeekCompleted`, and attaches it to the <xref:System.Messaging.MessageQueue.PeekCompleted> event handler delegate. <xref:System.Messaging.MessageQueue.BeginPeek%2A> is called, with a time-out of one minute. Each call to <xref:System.Messaging.MessageQueue.BeginPeek%2A> has a unique associated integer that identifies that particular operation. When a <xref:System.Messaging.MessageQueue.PeekCompleted> event is raised or the time-out expired, the message, if one exists, is retrieved and its body and the operation-specific integer identifier are written to the screen. Then <xref:System.Messaging.MessageQueue.BeginPeek%2A> is called again to initiate a new asynchronous peek operation with the same time-out and the associated integer of the just completed operation.  \n  \n [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]\n [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]\n [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]"
  metadata: {}
- returns:
    description: The <xref data-throw-if-not-resolved="true" uid="System.IAsyncResult"></xref> that identifies the posted asynchronous request.
    type: <xref href="System.IAsyncResult?alt=System.IAsyncResult&text=IAsyncResult" data-throw-if-not-resolved="True"/>
  parameters:
  - namesWithMoniker:
    - value: timeout
    description: A <xref data-throw-if-not-resolved="true" uid="System.TimeSpan"></xref> that indicates the interval of time to wait for a message to become available.
    type: <xref href="System.TimeSpan?alt=System.TimeSpan&text=TimeSpan" data-throw-if-not-resolved="True"/>
  - namesWithMoniker:
    - value: cursor
    description: A <xref data-throw-if-not-resolved="true" uid="System.Messaging.Cursor"></xref> that maintains a specific position in the message queue.
    type: <xref href="System.Messaging.Cursor?alt=System.Messaging.Cursor&text=Cursor" data-throw-if-not-resolved="True"/>
  - namesWithMoniker:
    - value: action
    description: One of the <xref data-throw-if-not-resolved="true" uid="System.Messaging.PeekAction"></xref> values. Indicates whether to peek at the current message in the queue, or the next message.
    type: <xref href="System.Messaging.PeekAction?alt=System.Messaging.PeekAction&text=PeekAction" data-throw-if-not-resolved="True"/>
  - namesWithMoniker:
    - value: state
    description: A state object, specified by the application, that contains information associated with the asynchronous operation.
    type: <xref href="System.Object?alt=System.Object&text=Object" data-throw-if-not-resolved="True"/>
  - namesWithMoniker:
    - value: callback
    description: The <xref data-throw-if-not-resolved="true" uid="System.AsyncCallback"></xref> that receives the notification of the asynchronous operation completion.
    type: <xref href="System.AsyncCallback?alt=System.AsyncCallback&text=AsyncCallback" data-throw-if-not-resolved="True"/>
  exceptions:
  - description: A value other than <code data-dev-comment-type="langword">PeekAction.Current</code> or <code data-dev-comment-type="langword">PeekAction.Next</code> was specified for the <code data-dev-comment-type="paramref">action</code> parameter.
    type: <xref href="System.ArgumentOutOfRangeException?alt=System.ArgumentOutOfRangeException&text=ArgumentOutOfRangeException" data-throw-if-not-resolved="True"/>
  - description: The <code data-dev-comment-type="paramref">cursor</code> parameter is <code data-dev-comment-type="langword">null</code>.
    type: <xref href="System.ArgumentNullException?alt=System.ArgumentNullException&text=ArgumentNullException" data-throw-if-not-resolved="True"/>
  - description: The value specified for the <code data-dev-comment-type="paramref">timeout</code> parameter is not valid.
    type: <xref href="System.ArgumentException?alt=System.ArgumentException&text=ArgumentException" data-throw-if-not-resolved="True"/>
  - description: An error occurred when accessing a Message Queuing method.
    type: <xref href="System.Messaging.MessageQueueException?alt=System.Messaging.MessageQueueException&text=MessageQueueException" data-throw-if-not-resolved="True"/>
  uid: System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)
  commentId: M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)
  name: BeginPeek(TimeSpan, Cursor, PeekAction, Object, AsyncCallback)
  fullName: System.Messaging.MessageQueue.BeginPeek(TimeSpan, Cursor, PeekAction, Object, AsyncCallback)
  nameWithType: MessageQueue.BeginPeek(TimeSpan, Cursor, PeekAction, Object, AsyncCallback)
  syntaxWithMoniker:
  - lang: cpp
    values:
    - value: >-
        public:
         IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action, System::Object ^ state, AsyncCallback ^ callback);
  - lang: csharp
    values:
    - value: public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);
  - lang: fsharp
    values:
    - value: 'member this.BeginPeek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction * obj * AsyncCallback -> IAsyncResult'
  - lang: vb
    values:
    - value: Public Function BeginPeek (timeout As TimeSpan, cursor As Cursor, action As PeekAction, state As Object, callback As AsyncCallback) As IAsyncResult
  monikers:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
  - netframework-4.5
  - netframework-4.5.1
  - netframework-4.5.2
  - netframework-4.6
  - netframework-4.6.1
  - netframework-4.6.2
  - netframework-4.7
  - netframework-4.7.1
  - netframework-4.7.2
  - netframework-4.8
  seeAlso: >+
    - <xref:System.Messaging.MessageQueue.PeekCompleted>

    - <xref:System.Messaging.MessageQueue.BeginReceive>

    - <xref:System.Messaging.MessageQueue.Peek>

    - <xref:System.Messaging.MessageQueue.Receive>

    - <xref:System.AsyncCallback>

    - <xref:System.TimeSpan>

  summary: Initiates an asynchronous peek operation that has a specified time-out and that uses a specified cursor, a specified peek action, and a specified state object. The state object provides associated information throughout the lifetime of the operation. This overload receives notification, through a callback, of the identity of the event handler for the operation. The operation is not complete until either a message becomes available in the queue or the time-out occurs.
  remarks: "When you use this overload, the callback specified in the callback parameter is invoked directly when a message becomes available in the queue or when the specified interval of time has expired. The <xref:System.Messaging.MessageQueue.PeekCompleted> event is not raised. The other overloads of <xref:System.Messaging.MessageQueue.BeginPeek%2A> rely on this component to raise the <xref:System.Messaging.MessageQueue.PeekCompleted> event.  \n  \n <xref:System.Messaging.MessageQueue.PeekCompleted> is also raised if a message already exists in the queue.  \n  \n The <xref:System.Messaging.MessageQueue.BeginPeek%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.  \n  \n Because <xref:System.Messaging.MessageQueue.BeginPeek%2A> is asynchronous, you can call it to peek the queue without blocking the current thread of execution. To synchronously peek the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.  \n  \n Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.  \n  \n <xref:System.Messaging.MessageQueue.BeginPeek%2A> returns a <xref:System.IAsyncResult> that identifies the asynchronous operation started by the method. You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> is called. However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete. In this case, use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.  \n  \n The state object associates state information with the operation. For example, if you call <xref:System.Messaging.MessageQueue.BeginPeek%2A> multiple times to initiate multiple operations, you can identify each operation through a separate state object that you define.  \n  \n The following table shows whether this method is available in various Workgroup modes.  \n  \n|Workgroup mode|Available|  \n|--------------------|---------------|  \n|Local computer|Yes|  \n|Local computer and direct format name|Yes|  \n|Remote computer|No|  \n|Remote computer and direct format name|Yes|"
  metadata: {}
- returns:
    description: The <xref data-throw-if-not-resolved="true" uid="System.IAsyncResult"></xref> that identifies the posted asynchronous request.
    type: <xref href="System.IAsyncResult?alt=System.IAsyncResult&text=IAsyncResult" data-throw-if-not-resolved="True"/>
  exceptions:
  - description: An error occurred when accessing a Message Queuing method.
    type: <xref href="System.Messaging.MessageQueueException?alt=System.Messaging.MessageQueueException&text=MessageQueueException" data-throw-if-not-resolved="True"/>
  uid: System.Messaging.MessageQueue.BeginPeek
  commentId: M:System.Messaging.MessageQueue.BeginPeek
  name: BeginPeek()
  fullName: System.Messaging.MessageQueue.BeginPeek()
  nameWithType: MessageQueue.BeginPeek()
  syntaxWithMoniker:
  - lang: cpp
    values:
    - value: >-
        public:
         IAsyncResult ^ BeginPeek();
  - lang: csharp
    values:
    - value: public IAsyncResult BeginPeek ();
  - lang: fsharp
    values:
    - value: 'member this.BeginPeek : unit -> IAsyncResult'
  - lang: vb
    values:
    - value: Public Function BeginPeek () As IAsyncResult
  monikers:
  - netframework-1.1
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
  - netframework-4.5
  - netframework-4.5.1
  - netframework-4.5.2
  - netframework-4.6
  - netframework-4.6.1
  - netframework-4.6.2
  - netframework-4.7
  - netframework-4.7.1
  - netframework-4.7.2
  - netframework-4.8
  - xamarinmac-3.0
  seeAlso: >+
    - <xref:System.Messaging.MessageQueue.PeekCompleted>

    - <xref:System.Messaging.MessageQueue.BeginReceive>

    - <xref:System.Messaging.MessageQueue.Peek>

    - <xref:System.Messaging.MessageQueue.Receive>

  summary: Initiates an asynchronous peek operation that has no time-out. The operation is not complete until a message becomes available in the queue.
  remarks: "In asynchronous processing, you use <xref:System.Messaging.MessageQueue.BeginPeek%2A> to raise the <xref:System.Messaging.MessageQueue.PeekCompleted> event when a message becomes available in the queue.  \n  \n <xref:System.Messaging.MessageQueue.PeekCompleted> is also raised if a message already exists in the queue.  \n  \n To use <xref:System.Messaging.MessageQueue.BeginPeek%2A>, create an event handler that processes the results of the asynchronous operation, and associate it with your event delegate. <xref:System.Messaging.MessageQueue.BeginPeek%2A> initiates an asynchronous peek operation; the <xref:System.Messaging.MessageQueue> is notified, through the raising of the <xref:System.Messaging.MessageQueue.PeekCompleted> event, when a message arrives in the queue. The <xref:System.Messaging.MessageQueue> can then access the message by calling <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> or by retrieving the result using the <xref:System.Messaging.PeekCompletedEventArgs>.  \n  \n The <xref:System.Messaging.MessageQueue.BeginPeek%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.  \n  \n Because <xref:System.Messaging.MessageQueue.BeginPeek%2A> is asynchronous, you can call it to peek the queue without blocking the current thread of execution. To synchronously peek the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.  \n  \n Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.  \n  \n The <xref:System.IAsyncResult> that <xref:System.Messaging.MessageQueue.BeginPeek%2A> returns identifies the asynchronous operation that the method started. You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> is called. However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete. In this case, you use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.  \n  \n If <xref:System.Messaging.MessageQueue.CanRead%2A> is `false`, the completion event is raised, but an exception will be thrown when calling <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  \n  \n The following table shows whether this method is available in various Workgroup modes.  \n  \n|Workgroup mode|Available|  \n|--------------------|---------------|  \n|Local computer|Yes|  \n|Local computer and direct format name|Yes|  \n|Remote computer|No|  \n|Remote computer and direct format name|Yes|"
  examples: "The following code example creates an event handler named `MyPeekCompleted`, attaches it to the <xref:System.Messaging.MessageQueue.PeekCompleted> event handler delegate, and calls <xref:System.Messaging.MessageQueue.BeginPeek%2A> to initiate an asynchronous peek operation on the queue that is located at the path \".\\myQueue\". When a <xref:System.Messaging.MessageQueue.PeekCompleted> event is raised, the example peeks the message and writes its body to the screen. The example then calls <xref:System.Messaging.MessageQueue.BeginPeek%2A> again to initiate a new asynchronous peek operation.  \n  \n [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]\n [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]\n [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]"
  metadata: {}
- returns:
    description: The <xref data-throw-if-not-resolved="true" uid="System.IAsyncResult"></xref> that identifies the posted asynchronous request.
    type: <xref href="System.IAsyncResult?alt=System.IAsyncResult&text=IAsyncResult" data-throw-if-not-resolved="True"/>
  parameters:
  - namesWithMoniker:
    - value: timeout
    description: A <xref data-throw-if-not-resolved="true" uid="System.TimeSpan"></xref> that indicates the interval of time to wait for a message to become available.
    type: <xref href="System.TimeSpan?alt=System.TimeSpan&text=TimeSpan" data-throw-if-not-resolved="True"/>
  exceptions:
  - description: The value specified for the <code data-dev-comment-type="paramref">timeout</code> parameter is not valid.
    type: <xref href="System.ArgumentException?alt=System.ArgumentException&text=ArgumentException" data-throw-if-not-resolved="True"/>
  - description: An error occurred when accessing a Message Queuing method.
    type: <xref href="System.Messaging.MessageQueueException?alt=System.Messaging.MessageQueueException&text=MessageQueueException" data-throw-if-not-resolved="True"/>
  uid: System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)
  commentId: M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)
  name: BeginPeek(TimeSpan)
  fullName: System.Messaging.MessageQueue.BeginPeek(TimeSpan)
  nameWithType: MessageQueue.BeginPeek(TimeSpan)
  syntaxWithMoniker:
  - lang: cpp
    values:
    - value: >-
        public:
         IAsyncResult ^ BeginPeek(TimeSpan timeout);
  - lang: csharp
    values:
    - value: public IAsyncResult BeginPeek (TimeSpan timeout);
  - lang: fsharp
    values:
    - value: 'member this.BeginPeek : TimeSpan -> IAsyncResult'
  - lang: vb
    values:
    - value: Public Function BeginPeek (timeout As TimeSpan) As IAsyncResult
  monikers:
  - netframework-1.1
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
  - netframework-4.5
  - netframework-4.5.1
  - netframework-4.5.2
  - netframework-4.6
  - netframework-4.6.1
  - netframework-4.6.2
  - netframework-4.7
  - netframework-4.7.1
  - netframework-4.7.2
  - netframework-4.8
  - xamarinmac-3.0
  seeAlso: >+
    - <xref:System.Messaging.MessageQueue.PeekCompleted>

    - <xref:System.Messaging.MessageQueue.BeginReceive>

    - <xref:System.Messaging.MessageQueue.Peek>

    - <xref:System.Messaging.MessageQueue.Receive>

    - <xref:System.TimeSpan>

  summary: Initiates an asynchronous peek operation that has a specified time-out. The operation is not complete until either a message becomes available in the queue or the time-out occurs.
  remarks: "In asynchronous processing, you use <xref:System.Messaging.MessageQueue.BeginPeek%2A> to raise the <xref:System.Messaging.MessageQueue.PeekCompleted> event when a message becomes available in the queue or when the specified interval of time has expired.  \n  \n <xref:System.Messaging.MessageQueue.PeekCompleted> is also raised if a message already exists in the queue.  \n  \n To use <xref:System.Messaging.MessageQueue.BeginPeek%2A>, create an event handler that processes the results of the asynchronous operation, and associate it with your event delegate. <xref:System.Messaging.MessageQueue.BeginPeek%2A> initiates an asynchronous peek operation; the <xref:System.Messaging.MessageQueue> is notified, through the raising of the <xref:System.Messaging.MessageQueue.PeekCompleted> event, when a message arrives in the queue. The <xref:System.Messaging.MessageQueue> can then access the message by calling <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> or by retrieving the result using the <xref:System.Messaging.PeekCompletedEventArgs>.  \n  \n The <xref:System.Messaging.MessageQueue.BeginPeek%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.  \n  \n Because <xref:System.Messaging.MessageQueue.BeginPeek%2A> is asynchronous, you can call it to peek the queue without blocking the current thread of execution. To synchronously peek the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.  \n  \n Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.  \n  \n The <xref:System.IAsyncResult> that <xref:System.Messaging.MessageQueue.BeginPeek%2A> returns identifies the asynchronous operation that the method started. You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> is called. However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete. In this case, you use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.  \n  \n This overload specifies a time-out. If the interval specified by the `timeout` parameter expires, this component raises the <xref:System.Messaging.MessageQueue.PeekCompleted> event. Because no message exists, a subsequent call to <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> will throw an exception.  \n  \n If <xref:System.Messaging.MessageQueue.CanRead%2A> is `false`, the completion event is raised, but an exception will be thrown when calling <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  \n  \n The following table shows whether this method is available in various Workgroup modes.  \n  \n|Workgroup mode|Available|  \n|--------------------|---------------|  \n|Local computer|Yes|  \n|Local computer and direct format name|Yes|  \n|Remote computer|No|  \n|Remote computer and direct format name|Yes|"
  examples: "The following code example creates an asynchronous peek operation, using the queue path \".\\myQueue\". It creates an event handler, `MyPeekCompleted`, and attaches it to the <xref:System.Messaging.MessageQueue.PeekCompleted> event handler delegate. <xref:System.Messaging.MessageQueue.BeginPeek%2A> is called with a time-out of one minute, to initiate the asynchronous peek operation. When a <xref:System.Messaging.MessageQueue.PeekCompleted> event is raised or the time-out expires, the message is retrieved if one exists, and its body is written to the screen. Then <xref:System.Messaging.MessageQueue.BeginPeek%2A> is called again to initiate a new asynchronous peek operation with the same time-out.  \n  \n [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]\n [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]\n [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]"
  metadata: {}
uid: System.Messaging.MessageQueue.BeginPeek*
commentId: Overload:System.Messaging.MessageQueue.BeginPeek
namespace: System.Messaging
name: BeginPeek
fullName: System.Messaging.MessageQueue.BeginPeek
nameWithType: MessageQueue.BeginPeek
assembliesWithMoniker:
- value: System.Messaging.dll
devLangs:
- csharp
- vb
- cpp
- fsharp
monikers:
- netframework-1.1
- netframework-2.0
- netframework-3.0
- netframework-3.5
- netframework-4.0
- netframework-4.5
- netframework-4.5.1
- netframework-4.5.2
- netframework-4.6
- netframework-4.6.1
- netframework-4.6.2
- netframework-4.7
- netframework-4.7.1
- netframework-4.7.2
- netframework-4.8
- xamarinmac-3.0
summary: Initiates an asynchronous peek operation by telling Message Queuing to begin peeking a message and notify the event handler when finished.
metadata:
  content_git_url: https://github.com/OPS-E2E-PPE/dotnet-api-docs/blob/master/xml/System.Messaging/MessageQueue.xml
  _op_overwriteFileGitUrl: https://github.com/OPS-E2E-PPE/dotnet-api-docs/blob/docs-build-v3/xml/System.Messaging/MessageQueue.xml
  original_ref_skeleton_git_url: https://github.com/OPS-E2E-PPE/dotnet-api-docs/blob/docs-build-v3/xml/System.Messaging/MessageQueue.xml
  api_name:
  - System.Messaging.MessageQueue.BeginPeek
  api_location:
  - System.Messaging.dll
  topic_type:
  - apiref
  api_type:
  - Assembly
  f1_keywords:
  - System.Messaging.MessageQueue.BeginPeek
  - System::Messaging::MessageQueue::BeginPeek
  helpviewer_keywords:
  - MessageQueue.BeginPeek method [.NET]
  - BeginPeek method [.NET], class MessageQueue
  - MessageQueue.BeginPeek(TimeSpan, Object, AsyncCallback) method [.NET]
  - BeginPeek(TimeSpan, Object, AsyncCallback) method [.NET], class MessageQueue
  - MessageQueue.BeginPeek(TimeSpan, Object) method [.NET]
  - BeginPeek(TimeSpan, Object) method [.NET], class MessageQueue
  - MessageQueue.BeginPeek(TimeSpan, Cursor, PeekAction, Object, AsyncCallback) method [.NET]
  - BeginPeek(TimeSpan, Cursor, PeekAction, Object, AsyncCallback) method [.NET], class MessageQueue
  - MessageQueue.BeginPeek() method [.NET]
  - BeginPeek() method [.NET], class MessageQueue
  - MessageQueue.BeginPeek(TimeSpan) method [.NET]
  - BeginPeek(TimeSpan) method [.NET], class MessageQueue
